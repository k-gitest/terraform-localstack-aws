name: Terraform Plan (Hybrid)

on:
  pull_request:
    branches: [main, develop]
    paths:
      - 'terraform/**'
      - 'bootstrap/**'
      - '.github/workflows/terraform-*.yml'

env:
  TF_VERSION: "1.5.0"
  AWS_REGION: "ap-northeast-1"

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  bootstrap-status:
    name: Check Bootstrap Status
    runs-on: ubuntu-latest
    outputs:
      bootstrap_ready: ${{ steps.check.outputs.bootstrap_ready }}
      missing_secrets: ${{ steps.check.outputs.missing_secrets }}
    steps:
      - name: Check Bootstrap Status
        id: check
        run: |
          # GitHub Secrets„ÅÆÂ≠òÂú®Á¢∫Ë™ç
          missing_secrets=""
          bootstrap_ready="true"
          
          # ÂøÖË¶Å„Å™Secrets„Çí„ÉÅ„Çß„ÉÉ„ÇØ(dev, prod„ÅØÂøÖÈ†àË®≠ÂÆö)
          if [ -z "${{ secrets.AWS_ROLE_ARN_DEV }}" ]; then
            missing_secrets="$missing_secrets AWS_ROLE_ARN_DEV"
            bootstrap_ready="false"
          fi
          
          if [ -z "${{ secrets.AWS_ROLE_ARN_PROD }}" ]; then
            missing_secrets="$missing_secrets AWS_ROLE_ARN_PROD"
            bootstrap_ready="false"
          fi
          
          # local„ÅÆsecretsÂ≠òÂú®Á¢∫Ë™çÔºàlocalÁí∞Â¢É„ÅØ„Ç™„Éó„Ç∑„Éß„É≥ - Ë≠¶Âëä„ÅÆ„ÅøÔºâ
          if [ -z "${{ secrets.AWS_ROLE_ARN_LOCAL }}" ]; then
            echo "‚ö†Ô∏è Warning: AWS_ROLE_ARN_LOCAL not found (local environment will be skipped)"
          fi
          
          echo "bootstrap_ready=$bootstrap_ready" >> $GITHUB_OUTPUT
          echo "missing_secrets=$missing_secrets" >> $GITHUB_OUTPUT
          
          if [ "$bootstrap_ready" = "true" ]; then
            echo "‚úÖ Bootstrap is ready - All Role ARNs found"
          else
            echo "‚ùå Bootstrap required - Missing secrets: $missing_secrets"
          fi

  detect-changes:
    name: Detect Changed Environments
    runs-on: ubuntu-latest
    needs: bootstrap-status
    if: needs.bootstrap-status.outputs.bootstrap_ready == 'true'
    outputs:
      environments: ${{ steps.detect.outputs.environments }}
      segments: ${{ steps.detect.outputs.segments }}
      has_changes: ${{ steps.detect.outputs.has_changes }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect Changes
        id: detect
        run: |
          # Â§âÊõ¥„Åï„Çå„Åü„Éï„Ç°„Ç§„É´„ÇíÂèñÂæó ...‰∏âÁÇπ„É™„Éº„ÉÄ„ÅßÊó¢Â≠ò„Ç≥„Éü„ÉÉ„Éà„Åã„ÇâÊúÄÊñ∞„Ç≥„Éü„ÉÉ„Éà„Åæ„Åß„ÇíÊØîËºÉ„Åô„Çã
          # grep„Åß„Éë„Çø„Éº„É≥„Éû„ÉÉ„ÉÅ„Åô„ÇãÁÇ∫„ÄÅ^()„Å™„Å©„Çí-E„ÅßÊã°ÂºµÊ≠£Ë¶èË°®Áèæ„Å´„Åó„Å¶„ÅÑ„Çã || true„ÅßterraformÈñ¢ÈÄ£‰ª•Â§ñ„ÅÆÂ§âÊõ¥„Ç≥„Éü„ÉÉ„Éà„ÇÇ„Ç®„É©„Éº„Å´„Åó„Å™„ÅÑ
          changed_files=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep -E '^(terraform|bootstrap)/' || true)
          
          # $changed_files„ÅÆÂ≠òÂú®„ÉÅ„Çß„ÉÉ„ÇØ„Åß„ÄÅÁ©∫„Å†„Å£„ÅüÂ†¥Âêà„ÅÆÂá∫ÂäõË®≠ÂÆö„ÄÅË¶Å„ÅØterraformÈñ¢ÈÄ£„Åò„ÇÉ„Å™„ÅÑÂ†¥Âêà„ÅØhas_changes„Å´false„ÇíÂÖ•„Çå„Çã
          if [ -z "$changed_files" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "environments=[]" >> $GITHUB_OUTPUT
            echo "segments=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # $changed_files„ÅåÁ©∫„Åò„ÇÉ„Å™„ÅÑÂ†¥Âêà„ÄÅhas_changes„Å´true„ÇíÂÖ•„Çå„Å¶Âá∫Âäõ„Åô„Çã
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "Changed files:"
          echo "$changed_files"
          
          # Áí∞Â¢É„ÇíÊ§úÂá∫
          # grep„Åß-o ( --only-matching „ÅÆÁü≠Á∏ÆÂΩ¢) „Çí‰ΩøÁî®„Åó„Å¶Áí∞Â¢ÉÊñáÂ≠ó„Å†„ÅëÂèñÂæóÔºà‰æãÔºöenvironments/devÔºâ
          # cut„Åß-d„ÅÆÂå∫Âàá„ÇäÊñáÂ≠ó„Çí/„Å´ÊåáÂÆö„Åó„ÄÅ-f2„Å®„Åó„Å¶2Áï™ÁõÆ„ÅÆ„Éï„Ç£„Éº„É´„ÉâÊñáÂ≠óÂàó„ÇíÂèñÂæóÔºà‰æãÔºödevÔºâ
          # sort„Åó„Å¶-uÔºàuniqueÔºâ„ÅßÈáçË§á„ÇíÂâäÈô§
          # jq -R -s -c 'split("\n")[:-1]'„Åß1Ë°å„ÅÆJSONÈÖçÂàó„Å´Â§âÊèõ„ÄÄ
          # -R (raw input)„ÄÄjq„Å´‰∏é„Åà„Çâ„Çå„ÅüÂÖ•Âäõ„Çí„ÄÅJSON„Å®„Åó„Å¶„Éë„Éº„Çπ„Åô„Çã„ÅÆ„Åß„ÅØ„Å™„Åè„ÄÅÂçò„Å™„ÇãÊñáÂ≠óÂàó„Å®„Åó„Å¶Ë™≠„ÅøËæº„Åæ„Åõ„Åæ„Åô
          # -s (slurp)„ÄÄ-R„ÅßË™≠„ÅøËæº„Çì„Å†Ë§áÊï∞„ÅÆÊñáÂ≠óÂàó„Çí„ÄÅ1„Å§„ÅÆÈÖçÂàó„Å´„Åæ„Å®„ÇÅ„Å¶„Åã„Çâjq„Éï„Ç£„É´„Çø„Å´Ê∏°„Åó„Åæ„Åô
          # ‰æã„Åà„Å∞„ÄÅÂÖ•Âäõ„Åådev\nprod\n„ÅÆÂ†¥Âêà„ÄÅ-R„Å†„Åë„Åß„ÅØ"dev"„Å®"prod"„ÅåÂà•„ÄÖ„Å´Âá¶ÁêÜ„Åï„Çå„Åæ„Åô„Åå„ÄÅ-Rs„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„Çã„Å®„ÄÅ"dev\nprod\n"„Å®‰∏Ä„Å§„ÅÆÊñáÂ≠óÂàó„Å´„Å™„Çã
          # -c (compact output) jq„ÅÆÂá∫Âäõ„ÇíÊîπË°å„Å™„Åó„ÅÆ„Ç≥„É≥„Éë„ÇØ„Éà„Å™1Ë°å„Å´„Åó„Åæ„Åô
          # ÊîπË°å„Çísplit„ÅßÂå∫Âàá„Çä„ÄÅÊú´Â∞æÊîπË°å„Å´„Çà„ÇãÁ©∫ÊñáÂ≠óÂàó„Çí[:-1]„ÅßÊú´Â∞æ„Åã„Çâ‰∏Ä„Å§Ââç„Å®ÊåáÂÆö„Åó„Å¶ÈÖçÂàó„Åã„ÇâÈô§Â§ñ„Åô„ÇãÔºà‰æãÔºö["dev", "prod", ""] => ["dev", "prod"]Ôºâ
          environments=$(echo "$changed_files" | grep -oE 'environments/(local|dev|prod)' | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n")[:-1]' || echo '[]')

          # local„ÅåÂê´„Åæ„Çå„ÇãÂ†¥Âêà„ÄÅAWS_ROLE_ARN_LOCAL„ÅÆÂ≠òÂú®Á¢∫Ë™ç
          if echo "$environments" | jq -e 'index("local")' >/dev/null 2>&1; then
            if [ -z "${{ secrets.AWS_ROLE_ARN_LOCAL }}" ]; then
              echo "‚ö†Ô∏è Warning: local environment detected but AWS_ROLE_ARN_LOCAL not configured - excluding local"
              environments=$(echo "$environments" | jq -c 'map(select(. != "local"))')
            fi
          fi

          echo "environments=$environments" >> $GITHUB_OUTPUT
          
          # „Çª„Ç∞„É°„É≥„Éà„ÇíÊ§úÂá∫
          segments=$(echo "$changed_files" | grep -oE 'segments/(foundation|application|data_processing)' | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n")[:-1]' || echo '[]')
          echo "segments=$segments" >> $GITHUB_OUTPUT

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [bootstrap-status, detect-changes] # bootstrap-status, detect-changes„Ç∏„Éß„Éñ„ÅåÂÆå‰∫Ü„Åô„Çã„Åæ„ÅßÂæÖÊ©ü„Åô„Çã
    if: needs.bootstrap-status.outputs.bootstrap_ready == 'true' && needs.detect-changes.outputs.has_changes == 'true'
    # planÂÆüË°åÊôÇÈñì„ÅÆÁü≠Á∏Æ„Åü„ÇÅstrategy matrix„ÇíË®≠ÂÆö„Åódev, prod„Çí‰∏¶Âàó„ÅßÂÆüË°å„Åô„Çã
    strategy:
      matrix:
        environment: fromJson(needs.detect-changes.outputs.environments)
      fail-fast: false # „Å©„Å°„Çâ„Åã„ÅÆÁí∞Â¢É„ÅåÂ§±Êïó„Åó„Å¶„ÇÇÁ∂ôÁ∂ö
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Role ARN
        id: get-role
        run: |
          case "${{ matrix.environment }}" in
            dev)
              echo "role=${{ secrets.AWS_ROLE_ARN_DEV }}" >> $GITHUB_OUTPUT
              ;;
            prod)
              echo "role=${{ secrets.AWS_ROLE_ARN_PROD }}" >> $GITHUB_OUTPUT
              ;;
            local)
              echo "role=${{ secrets.AWS_ROLE_ARN_LOCAL }}" >> $GITHUB_OUTPUT
              ;;
            *) # defaultË®≠ÂÆö
              echo "‚ùå Unknown environment: ${{ matrix.environment }}"
              exit 1
              ;;
          esac

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          # matrix„ÅßÂÆöÁæ©„Åó„ÅüroleÂ§âÊï∞„Çí‰ΩøÁî®
          role-to-assume: ${{ steps.get-role.outputs.role }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Plan (Standard)
        id: plan-standard
        run: |
          echo "Running plan for environment: ${{ matrix.environment }}"
          make ${{ matrix.environment }}-plan
        continue-on-error: true

      - name: Format Plan Output
        if: always()
        id: format
        run: |
          # „Éó„É©„É≥ÁµêÊûú„Çí„Éï„Ç©„Éº„Éû„ÉÉ„Éà
          if [ "${{ steps.plan-standard.outcome }}" = "success" ]; then
            echo "PLAN_STATUS=‚úÖ Success" >> $GITHUB_ENV
          else
            echo "PLAN_STATUS=‚ùå Failed" >> $GITHUB_ENV
          fi

      - name: Comment PR (Standard)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const environment = '${{ matrix.environment }}';
            const status = process.env.PLAN_STATUS;
            const outcome = '${{ steps.plan-standard.outcome }}';
            
            const body = `
            ## üìã Terraform Plan Results (Standard)
            
            **Environment**: \`${environment}\`
            **Status**: ${status}
            **Configuration**: \`terraform/environments/${environment}/\`
            
            ${outcome === 'success' ? 
              '‚úÖ Plan completed successfully. Review the changes before merging.' : 
              '‚ùå Plan failed. Please check the logs and fix any issues.'
            }
            
            <details>
            <summary>üìÅ Configuration Details</summary>
            
            - **Path**: \`terraform/environments/${environment}/\`
            - **Command**: \`make ${environment}-plan\`
            - **Provider**: Standard Terraform
            
            </details>
            `;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes(`## üìã Terraform Plan Results (Standard)`) &&
              comment.body.includes(`**Environment**: \`${environment}\``)
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  segment-plan:
    name: Segment Plan
    runs-on: ubuntu-latest
    needs: [bootstrap-status, detect-changes]
    if: needs.bootstrap-status.outputs.bootstrap_ready == 'true' && needs.detect-changes.outputs.has_changes == 'true' && needs.detect-changes.outputs.segments != '[]'
    strategy:
      matrix:
        segment: ${{ fromJson(needs.detect-changes.outputs.segments) }}
        environment: ${{ fromJson(needs.detect-changes.outputs.environments) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Get Role ARN
        id: get-role
        run: |
          case "${{ matrix.environment }}" in
            dev)
              echo "role=${{ secrets.AWS_ROLE_ARN_DEV }}" >> $GITHUB_OUTPUT
              ;;
            prod)
              echo "role=${{ secrets.AWS_ROLE_ARN_PROD }}" >> $GITHUB_OUTPUT
              ;;
            local)
              if [ -n "${{ secrets.AWS_ROLE_ARN_LOCAL }}" ]; then
                echo "role=${{ secrets.AWS_ROLE_ARN_LOCAL }}" >> $GITHUB_OUTPUT
              else
                echo "‚ùå AWS_ROLE_ARN_LOCAL not configured"
                exit 1
              fi
              ;;
            *)
              echo "‚ùå Unknown environment: ${{ matrix.environment }}"
              exit 1
              ;;
          esac

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          role-to-assume: ${{ steps.get-role.outputs.role }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Segment Plan
        id: plan-segment
        run: |
          echo "Running segment plan for: ${{ matrix.segment }}-${{ matrix.environment }}"
          make seg-${{ matrix.segment }}-${{ matrix.environment }}-plan
        continue-on-error: true

      - name: Comment PR (Segment)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const segment = '${{ matrix.segment }}';
            const environment = '${{ matrix.environment }}';
            const outcome = '${{ steps.plan-segment.outcome }}';
            const status = outcome === 'success' ? '‚úÖ Success' : '‚ùå Failed';
            
            const body = `
            ## üß© Segment Plan Results
            
            **Segment**: \`${segment}\`
            **Environment**: \`${environment}\`
            **Status**: ${status}
            **Configuration**: \`terraform/segments/${segment}/environments/${environment}/\`
            
            ${outcome === 'success' ? 
              '‚úÖ Segment plan completed successfully.' : 
              '‚ùå Segment plan failed. Please check the logs.'
            }
            
            <details>
            <summary>üìÅ Segment Details</summary>
            
            - **Path**: \`terraform/segments/${segment}/environments/${environment}/\`
            - **Command**: \`make seg-${segment}-${environment}-plan\`
            - **Type**: Segment-based configuration
            
            </details>
            `;
            
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes(`## üß© Segment Plan Results`) &&
              comment.body.includes(`**Segment**: \`${segment}\``) &&
              comment.body.includes(`**Environment**: \`${environment}\``)
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

  bootstrap-required:
    name: Bootstrap Setup Required
    runs-on: ubuntu-latest
    needs: bootstrap-status
    if: needs.bootstrap-status.outputs.bootstrap_ready == 'false'
    steps:
      - name: Bootstrap Instructions
        run: |
          echo "## ‚ö†Ô∏è Bootstrap Setup Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "OIDC authentication infrastructure needs to be configured." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Missing GitHub Secrets:" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.bootstrap-status.outputs.missing_secrets }}" | tr ' ' '\n' | while read secret; do
            if [ -n "$secret" ]; then
              echo "- \`$secret\`" >> $GITHUB_STEP_SUMMARY
            fi
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üõ†Ô∏è Setup Options:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Option 1: Manual Setup (Recommended)" >> $GITHUB_STEP_SUMMARY
          echo "1. Run bootstrap locally with AWS CLI credentials" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo 'cd bootstrap' >> $GITHUB_STEP_SUMMARY
          echo 'terraform init' >> $GITHUB_STEP_SUMMARY
          echo 'terraform apply' >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "2. Copy Role ARNs from output to GitHub Secrets" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Option 2: Workflow Setup (If AWS Access Keys Available)" >> $GITHUB_STEP_SUMMARY
          echo "1. Add temporary \`AWS_ACCESS_KEY_ID\` and \`AWS_SECRET_ACCESS_KEY\` to secrets" >> $GITHUB_STEP_SUMMARY
          echo "2. Run 'Bootstrap OIDC Setup' workflow manually" >> $GITHUB_STEP_SUMMARY
          echo "3. Remove temporary credentials after OIDC setup completes" >> $GITHUB_STEP_SUMMARY

      - name: Comment PR
        uses: actions/github-script@v7
        with:
          script: |
            const missingSecrets = '${{ needs.bootstrap-status.outputs.missing_secrets }}';
            const secretsList = missingSecrets.split(' ')
              .filter(s => s.length > 0)
              .map(s => `- \`${s}\``)
              .join('\n');
            
            const body = `## ‚ö†Ô∏è Bootstrap Setup Required
            
            The OIDC authentication infrastructure needs to be configured before Terraform can run.
            
            ### Missing GitHub Secrets:
            ${secretsList}
            
            ### üõ†Ô∏è Quick Setup:
            
            1. **Run bootstrap locally:**
               \`\`\`bash
               cd bootstrap
               terraform init
               terraform apply
               \`\`\`
            
            2. **Add Role ARNs to GitHub Secrets:**
               - Go to [Repository Settings > Secrets](https://github.com/${{ github.repository }}/settings/secrets/actions)
               - Add the Role ARNs from terraform output
            
            3. **Re-run this workflow**
            
            ### üí° Alternative:
            Use the [Bootstrap OIDC Setup workflow](../../actions) if you have temporary AWS credentials available.
            
            ---
            *This is a one-time setup per repository.*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  plan-summary:
    name: Plan Summary
    runs-on: ubuntu-latest
    needs: [bootstrap-status, detect-changes, terraform-plan, segment-plan]
    if: always() && (needs.terraform-plan.result != 'skipped' || needs.segment-plan.result != 'skipped' || needs.bootstrap-status.outputs.bootstrap_ready == 'false')
    steps:
      - name: Summary Comment
        uses: actions/github-script@v7
        with:
          script: |
            const bootstrapReady = '${{ needs.bootstrap-status.outputs.bootstrap_ready }}' === 'true';
            const standardResult = '${{ needs.terraform-plan.result }}';
            const segmentResult = '${{ needs.segment-plan.result }}';
            
            // ÂÆâÂÖ®„Å™JSONËß£Êûê
            let environments = [];
            let segments = [];
            
            try {
              const envOutput = '${{ needs.detect-changes.outputs.environments || "[]" }}';
              environments = typeof envOutput === 'string' ? JSON.parse(envOutput) : envOutput;
            } catch (e) {
              console.log('Failed to parse environments output:', e);
              environments = [];
            }
            
            try {
              const segOutput = '${{ needs.detect-changes.outputs.segments || "[]" }}';
              segments = typeof segOutput === 'string' ? JSON.parse(segOutput) : segOutput;
            } catch (e) {
              console.log('Failed to parse segments output:', e);
              segments = [];
            }
            
            let summary = `## üìä Terraform Plan Summary\n\n`;
            
            if (!bootstrapReady) {
              summary += `**Bootstrap Status**: ‚ùå Setup Required\n`;
              summary += `**Action Required**: Configure OIDC authentication\n\n`;
              summary += `See the bootstrap instructions comment above.\n`;
            } else {
              summary += `**Bootstrap Status**: ‚úÖ Ready\n`;
              summary += `**Changed Environments**: ${environments.length > 0 ? environments.map(e => `\`${e}\``).join(', ') : 'None'}\n`;
              summary += `**Changed Segments**: ${segments.length > 0 ? segments.map(s => `\`${s}\``).join(', ') : 'None'}\n\n`;
              
              if (standardResult !== 'skipped') {
                summary += `**Standard Configuration**: ${standardResult === 'success' ? '‚úÖ' : '‚ùå'} ${standardResult}\n`;
              }
              
              if (segmentResult !== 'skipped') {
                summary += `**Segment Configuration**: ${segmentResult === 'success' ? '‚úÖ' : '‚ùå'} ${segmentResult}\n`;
              }
              
              if (standardResult === 'success' || segmentResult === 'success') {
                summary += `\n### üîç Next Steps\n`;
                summary += `- ‚úÖ Review the plan details above\n`;
                summary += `- ‚úÖ Merge this PR to apply changes\n`;
              } else if (standardResult === 'failure' || segmentResult === 'failure') {
                summary += `\n### üîç Next Steps\n`;
                summary += `- ‚ùå Fix any plan errors before merging\n`;
                summary += `- üîç Check workflow logs for detailed error information\n`;
              }
            }
            
            summary += `\n---\n*Generated by GitHub Actions ‚Ä¢ [View Workflow](${context.payload.repository.html_url}/actions/runs/${context.runId})*`;
            
            // „Ç≥„É°„É≥„Éà„ÅÆ update-or-create
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(c =>
              c.body.includes("## üìä Terraform Plan Summary")
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: summary
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: summary
              });
            }